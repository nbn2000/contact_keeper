{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar picomatch = require('picomatch');\n\nvar normalizePath = require('normalize-path');\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\n\n\nvar BANG = '!';\nvar DEFAULT_OPTIONS = {\n  returnIndex: false\n};\n\nvar arrify = function arrify(item) {\n  return Array.isArray(item) ? item : [item];\n};\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\n\n\nvar createPattern = function createPattern(matcher, options) {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n\n  if (typeof matcher === 'string') {\n    var glob = picomatch(matcher, options);\n    return function (string) {\n      return matcher === string || glob(string);\n    };\n  }\n\n  if (matcher instanceof RegExp) {\n    return function (string) {\n      return matcher.test(string);\n    };\n  }\n\n  return function (string) {\n    return false;\n  };\n};\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\n\n\nvar matchPatterns = function matchPatterns(patterns, negPatterns, args, returnIndex) {\n  var isList = Array.isArray(args);\n\n  var _path = isList ? args[0] : args;\n\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n\n  var path = normalizePath(_path);\n\n  for (var index = 0; index < negPatterns.length; index++) {\n    var nglob = negPatterns[index];\n\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  var applied = isList && [path].concat(args.slice(1));\n\n  for (var _index = 0; _index < patterns.length; _index++) {\n    var pattern = patterns[_index];\n\n    if (isList ? pattern.apply(void 0, _toConsumableArray(applied)) : pattern(path)) {\n      return returnIndex ? _index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\n\n\nvar anymatch = function anymatch(matchers, testString) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n\n  var opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  var returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n  var mtchers = arrify(matchers);\n  var negatedGlobs = mtchers.filter(function (item) {\n    return typeof item === 'string' && item.charAt(0) === BANG;\n  }).map(function (item) {\n    return item.slice(1);\n  }).map(function (item) {\n    return picomatch(item, opts);\n  });\n  var patterns = mtchers.filter(function (item) {\n    return typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG;\n  }).map(function (matcher) {\n    return createPattern(matcher, opts);\n  });\n\n  if (testString == null) {\n    return function (testString) {\n      var ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;","map":null,"metadata":{},"sourceType":"script"}