{"ast":null,"code":"var debug = require('debug')('nodemon:run');\n\nvar statSync = require('fs').statSync;\n\nvar utils = require('../utils');\n\nvar bus = utils.bus;\n\nvar childProcess = require('child_process');\n\nvar spawn = childProcess.spawn;\nvar exec = childProcess.exec;\nvar execSync = childProcess.execSync;\nvar fork = childProcess.fork;\n\nvar watch = require('./watch').watch;\n\nvar config = require('../config');\n\nvar child = null; // the actual child process we spawn\n\nvar killedAfterChange = false;\n\nvar noop = function noop() {};\n\nvar restart = null;\n\nvar psTree = require('pstree.remy');\n\nvar path = require('path');\n\nvar signals = require('./signals');\n\nvar osRelease = parseInt(require('os').release().split('.')[0], 10);\n\nfunction run(options) {\n  var cmd = config.command.raw; // moved up\n  // we need restart function below in the global scope for run.kill\n\n  /*jshint validthis:true*/\n\n  restart = run.bind(this, options);\n  run.restart = restart; // binding options with instance of run\n  // so that we can use it in run.kill\n\n  run.options = options;\n  var runCmd = !options.runOnChangeOnly || config.lastStarted !== 0;\n\n  if (runCmd) {\n    utils.log.status('starting `' + config.command.string + '`');\n  } else {\n    // should just watch file if command is not to be run\n    // had another alternate approach\n    // to stop process being forked/spawned in the below code\n    // but this approach does early exit and makes code cleaner\n    debug('start watch on: %s', config.options.watch);\n\n    if (config.options.watch !== false) {\n      watch();\n      return;\n    }\n  }\n\n  config.lastStarted = Date.now();\n  var stdio = ['pipe', 'pipe', 'pipe'];\n\n  if (config.options.stdout) {\n    stdio = ['pipe', process.stdout, process.stderr];\n  }\n\n  if (config.options.stdin === false) {\n    stdio = [process.stdin, process.stdout, process.stderr];\n  }\n\n  var sh = 'sh';\n  var shFlag = '-c';\n  var binPath = process.cwd() + '/node_modules/.bin';\n  var spawnOptions = {\n    env: Object.assign({}, process.env, options.execOptions.env, {\n      PATH: binPath + path.delimiter + process.env.PATH\n    }),\n    stdio: stdio\n  };\n  var executable = cmd.executable;\n\n  if (utils.isWindows) {\n    // if the exec includes a forward slash, reverse it for windows compat\n    // but *only* apply to the first command, and none of the arguments.\n    // ref #1251 and #1236\n    if (executable.indexOf('/') !== -1) {\n      executable = executable.split(' ').map(function (e, i) {\n        if (i === 0) {\n          return path.normalize(e);\n        }\n\n        return e;\n      }).join(' ');\n    } // taken from npm's cli: https://git.io/vNFD4\n\n\n    sh = process.env.comspec || 'cmd';\n    shFlag = '/d /s /c';\n    spawnOptions.windowsVerbatimArguments = true;\n  }\n\n  var args = runCmd ? utils.stringify(executable, cmd.args) : ':';\n  var spawnArgs = [sh, [shFlag, args], spawnOptions];\n  var firstArg = cmd.args[0] || '';\n  var inBinPath = false;\n\n  try {\n    inBinPath = statSync(\"\".concat(binPath, \"/\").concat(executable)).isFile();\n  } catch (e) {} // hasStdio allows us to correctly handle stdin piping\n  // see: https://git.io/vNtX3\n\n\n  var hasStdio = utils.satisfies('>= 6.4.0 || < 5'); // forking helps with sub-process handling and tends to clean up better\n  // than spawning, but it should only be used under specific conditions\n\n  var shouldFork = !config.options.spawn && !inBinPath && !(firstArg.indexOf('-') === 0) && // don't fork if there's a node exec arg\n  firstArg !== 'inspect' && // don't fork it's `inspect` debugger\n  executable === 'node' && // only fork if node\n  utils.version.major > 4; // only fork if node version > 4\n\n  if (shouldFork) {\n    // this assumes the first argument is the script and slices it out, since\n    // we're forking\n    var forkArgs = cmd.args.slice(1);\n    var env = utils.merge(options.execOptions.env, process.env);\n    stdio.push('ipc');\n    child = fork(options.execOptions.script, forkArgs, {\n      env: env,\n      stdio: stdio,\n      silent: !hasStdio\n    });\n    utils.log.detail('forking');\n    debug('fork', sh, shFlag, args);\n  } else {\n    utils.log.detail('spawning');\n    child = spawn.apply(null, spawnArgs);\n    debug('spawn', sh, shFlag, args);\n  }\n\n  if (config.required) {\n    var emit = {\n      stdout: function stdout(data) {\n        bus.emit('stdout', data);\n      },\n      stderr: function stderr(data) {\n        bus.emit('stderr', data);\n      }\n    }; // now work out what to bind to...\n\n    if (config.options.stdout) {\n      child.on('stdout', emit.stdout).on('stderr', emit.stderr);\n    } else {\n      child.stdout.on('data', emit.stdout);\n      child.stderr.on('data', emit.stderr);\n      bus.stdout = child.stdout;\n      bus.stderr = child.stderr;\n    }\n\n    if (shouldFork) {\n      child.on('message', function (message, sendHandle) {\n        bus.emit('message', message, sendHandle);\n      });\n    }\n  }\n\n  bus.emit('start');\n  utils.log.detail('child pid: ' + child.pid);\n  child.on('error', function (error) {\n    bus.emit('error', error);\n\n    if (error.code === 'ENOENT') {\n      utils.log.error('unable to run executable: \"' + cmd.executable + '\"');\n      process.exit(1);\n    } else {\n      utils.log.error('failed to start child process: ' + error.code);\n      throw error;\n    }\n  });\n  child.on('exit', function (code, signal) {\n    if (child && child.stdin) {\n      process.stdin.unpipe(child.stdin);\n    }\n\n    if (code === 127) {\n      utils.log.error('failed to start process, \"' + cmd.executable + '\" exec not found');\n      bus.emit('error', code);\n      process.exit();\n    } // If the command failed with code 2, it may or may not be a syntax error\n    // See: http://git.io/fNOAR\n    // We will only assume a parse error, if the child failed quickly\n\n\n    if (code === 2 && Date.now() < config.lastStarted + 500) {\n      utils.log.error('process failed, unhandled exit code (2)');\n      utils.log.error('');\n      utils.log.error('Either the command has a syntax error,');\n      utils.log.error('or it is exiting with reserved code 2.');\n      utils.log.error('');\n      utils.log.error('To keep nodemon running even after a code 2,');\n      utils.log.error('add this to the end of your command: || exit 1');\n      utils.log.error('');\n      utils.log.error('Read more here: https://git.io/fNOAG');\n      utils.log.error('');\n      utils.log.error('nodemon will stop now so that you can fix the command.');\n      utils.log.error('');\n      bus.emit('error', code);\n      process.exit();\n    } // In case we killed the app ourselves, set the signal thusly\n\n\n    if (killedAfterChange) {\n      killedAfterChange = false;\n      signal = config.signal;\n    } // this is nasty, but it gives it windows support\n\n\n    if (utils.isWindows && signal === 'SIGTERM') {\n      signal = config.signal;\n    }\n\n    if (signal === config.signal || code === 0) {\n      // this was a clean exit, so emit exit, rather than crash\n      debug('bus.emit(exit) via ' + config.signal);\n      bus.emit('exit', signal); // exit the monitor, but do it gracefully\n\n      if (signal === config.signal) {\n        return restart();\n      }\n\n      if (code === 0) {\n        // clean exit - wait until file change to restart\n        if (runCmd) {\n          utils.log.status('clean exit - waiting for changes before restart');\n        }\n\n        child = null;\n      }\n    } else {\n      bus.emit('crash');\n\n      if (options.exitcrash) {\n        utils.log.fail('app crashed');\n\n        if (!config.required) {\n          process.exit(1);\n        }\n      } else {\n        utils.log.fail('app crashed - waiting for file changes before' + ' starting...');\n        child = null;\n      }\n    }\n\n    if (config.options.restartable) {\n      // stdin needs to kick in again to be able to listen to the\n      // restart command\n      process.stdin.resume();\n    }\n  }); // moved the run.kill outside to handle both the cases\n  // intial start\n  // no start\n  // connect stdin to the child process (options.stdin is on by default)\n\n  if (options.stdin) {\n    process.stdin.resume(); // FIXME decide whether or not we need to decide the encoding\n    // process.stdin.setEncoding('utf8');\n    // swallow the stdin error if it happens\n    // ref: https://github.com/remy/nodemon/issues/1195\n\n    if (hasStdio) {\n      child.stdin.on('error', function () {});\n      process.stdin.pipe(child.stdin);\n    } else {\n      if (child.stdout) {\n        child.stdout.pipe(process.stdout);\n      } else {\n        utils.log.error('running an unsupported version of node ' + process.version);\n        utils.log.error('nodemon may not work as expected - ' + 'please consider upgrading to LTS');\n      }\n    }\n\n    bus.once('exit', function () {\n      if (child && process.stdin.unpipe) {\n        // node > 0.8\n        process.stdin.unpipe(child.stdin);\n      }\n    });\n  }\n\n  debug('start watch on: %s', config.options.watch);\n\n  if (config.options.watch !== false) {\n    watch();\n  }\n}\n\nfunction waitForSubProcesses(pid, callback) {\n  debug('checking ps tree for pids of ' + pid);\n  psTree(pid, function (err, pids) {\n    if (!pids.length) {\n      return callback();\n    }\n\n    utils.log.status(\"still waiting for \".concat(pids.length, \" sub-process\").concat(pids.length > 2 ? 'es' : '', \" to finish...\"));\n    setTimeout(function () {\n      return waitForSubProcesses(pid, callback);\n    }, 1000);\n  });\n}\n\nfunction kill(child, signal, callback) {\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (utils.isWindows) {\n    var taskKill = function taskKill() {\n      try {\n        exec('taskkill /pid ' + child.pid + ' /T /F');\n      } catch (e) {\n        utils.log.error('Could not shutdown sub process cleanly');\n      }\n    }; // We are handling a 'SIGKILL' , 'SIGUSR2' and 'SIGUSR1' POSIX signal under Windows the\n    // same way it is handled on a UNIX system: We are performing\n    // a hard shutdown without waiting for the process to clean-up.\n\n\n    if (signal === 'SIGKILL' || osRelease < 10 || signal === 'SIGUSR2' || signal === \"SIGUSR1\") {\n      debug('terminating process group by force: %s', child.pid); // We are using the taskkill utility to terminate the whole\n      // process group ('/t') of the child ('/pid') by force ('/f').\n      // We need to end all sub processes, because the 'child'\n      // process in this context is actually a cmd.exe wrapper.\n\n      taskKill();\n      callback();\n      return;\n    }\n\n    try {\n      // We are using the Windows Management Instrumentation Command-line\n      // (wmic.exe) to resolve the sub-child process identifier, because the\n      // 'child' process in this context is actually a cmd.exe wrapper.\n      // We want to send the termination signal directly to the node process.\n      // The '2> nul' silences the no process found error message.\n      var resultBuffer = execSync(\"wmic process where (ParentProcessId=\".concat(child.pid, \") get ProcessId 2> nul\"));\n      var result = resultBuffer.toString().match(/^[0-9]+/m); // If there is no sub-child process we fall back to the child process.\n\n      var processId = Array.isArray(result) ? result[0] : child.pid;\n      debug('sending kill signal SIGINT to process: %s', processId); // We are using the standalone 'windows-kill' executable to send the\n      // standard POSIX signal 'SIGINT' to the node process. This fixes #1720.\n\n      var windowsKill = path.normalize(\"\".concat(__dirname, \"/../../bin/windows-kill.exe\")); // We have to detach the 'windows-kill' execution completely from this\n      // process group to avoid terminating the nodemon process itself.\n      // See: https://github.com/alirdn/windows-kill#how-it-works--limitations\n      //\n      // Therefore we are using 'start' to create a new cmd.exe context.\n      // The '/min' option hides the new terminal window and the '/wait'\n      // option lets the process wait for the command to finish.\n\n      execSync(\"start \\\"windows-kill\\\" /min /wait \\\"\".concat(windowsKill, \"\\\" -SIGINT \").concat(processId));\n    } catch (e) {\n      taskKill();\n    }\n\n    callback();\n  } else {\n    // we use psTree to kill the full subtree of nodemon, because when\n    // spawning processes like `coffee` under the `--debug` flag, it'll spawn\n    // it's own child, and that can't be killed by nodemon, so psTree gives us\n    // an array of PIDs that have spawned under nodemon, and we send each the\n    // configured signal (default: SIGUSR2) signal, which fixes #335\n    // note that psTree also works if `ps` is missing by looking in /proc\n    var sig = signal.replace('SIG', '');\n    psTree(child.pid, function (err, pids) {\n      // if ps isn't native to the OS, then we need to send the numeric value\n      // for the signal during the kill, `signals` is a lookup table for that.\n      if (!psTree.hasPS) {\n        sig = signals[signal];\n      } // the sub processes need to be killed from smallest to largest\n\n\n      debug('sending kill signal to ' + pids.join(', '));\n      child.kill(signal);\n      pids.sort().forEach(function (pid) {\n        return exec(\"kill -\".concat(sig, \" \").concat(pid), noop);\n      });\n      waitForSubProcesses(child.pid, function () {\n        // finally kill the main user process\n        exec(\"kill -\".concat(sig, \" \").concat(child.pid), callback);\n      });\n    });\n  }\n}\n\nrun.kill = function (noRestart, callback) {\n  // I hate code like this :(  - Remy (author of said code)\n  if (typeof noRestart === 'function') {\n    callback = noRestart;\n    noRestart = false;\n  }\n\n  if (!callback) {\n    callback = noop;\n  }\n\n  if (child !== null) {\n    // if the stdin piping is on, we need to unpipe, but also close stdin on\n    // the child, otherwise linux can throw EPIPE or ECONNRESET errors.\n    if (run.options.stdin) {\n      process.stdin.unpipe(child.stdin);\n    } // For the on('exit', ...) handler above the following looks like a\n    // crash, so we set the killedAfterChange flag if a restart is planned\n\n\n    if (!noRestart) {\n      killedAfterChange = true;\n    }\n    /* Now kill the entire subtree of processes belonging to nodemon */\n\n\n    var oldPid = child.pid;\n\n    if (child) {\n      kill(child, config.signal, function () {\n        // this seems to fix the 0.11.x issue with the \"rs\" restart command,\n        // though I'm unsure why. it seems like more data is streamed in to\n        // stdin after we close.\n        if (child && run.options.stdin && child.stdin && oldPid === child.pid) {\n          child.stdin.end();\n        }\n\n        callback();\n      });\n    }\n  } else if (!noRestart) {\n    // if there's no child, then we need to manually start the process\n    // this is because as there was no child, the child.on('exit') event\n    // handler doesn't exist which would normally trigger the restart.\n    bus.once('start', callback);\n    run.restart();\n  } else {\n    callback();\n  }\n};\n\nrun.restart = noop;\nbus.on('quit', function onQuit(code) {\n  if (code === undefined) {\n    code = 0;\n  } // remove event listener\n\n\n  var exitTimer = null;\n\n  var _exit = function exit() {\n    clearTimeout(exitTimer);\n    _exit = noop; // null out in case of race condition\n\n    child = null;\n\n    if (!config.required) {\n      // Execute all other quit listeners.\n      bus.listeners('quit').forEach(function (listener) {\n        if (listener !== onQuit) {\n          listener();\n        }\n      });\n      process.exit(code);\n    } else {\n      bus.emit('exit');\n    }\n  }; // if we're not running already, don't bother with trying to kill\n\n\n  if (config.run === false) {\n    return _exit();\n  } // immediately try to stop any polling\n\n\n  config.run = false;\n\n  if (child) {\n    // give up waiting for the kids after 10 seconds\n    exitTimer = setTimeout(_exit, 10 * 1000);\n    child.removeAllListeners('exit');\n    child.once('exit', _exit);\n    kill(child, 'SIGINT');\n  } else {\n    _exit();\n  }\n});\nbus.on('restart', function () {\n  // run.kill will send a SIGINT to the child process, which will cause it\n  // to terminate, which in turn uses the 'exit' event handler to restart\n  run.kill();\n}); // remove the child file on exit\n\nprocess.on('exit', function () {\n  utils.log.detail('exiting');\n\n  if (child) {\n    child.kill();\n  }\n}); // because windows borks when listening for the SIG* events\n\nif (!utils.isWindows) {\n  bus.once('boot', function () {\n    // usual suspect: ctrl+c exit\n    process.once('SIGINT', function () {\n      return bus.emit('quit', 130);\n    });\n    process.once('SIGTERM', function () {\n      bus.emit('quit', 143);\n\n      if (child) {\n        child.kill('SIGTERM');\n      }\n    });\n  });\n}\n\nmodule.exports = run;","map":null,"metadata":{},"sourceType":"script"}