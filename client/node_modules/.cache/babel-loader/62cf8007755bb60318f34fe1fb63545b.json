{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _possibleConstructorReturn = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _toConsumableArray = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/nbn2000/Desktop/Boilerplates/React Front to Back/contact-keeper/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar _require2 = require('util'),\n    promisify = _require2.promisify;\n\nvar readdirp = require('readdirp');\n\nvar anymatch = require('anymatch').default;\n\nvar globParent = require('glob-parent');\n\nvar isGlob = require('is-glob');\n\nvar braces = require('braces');\n\nvar normalizePath = require('normalize-path');\n\nvar NodeFsHandler = require('./lib/nodefs-handler');\n\nvar FsEventsHandler = require('./lib/fsevents-handler');\n\nvar _require3 = require('./lib/constants'),\n    EV_ALL = _require3.EV_ALL,\n    EV_READY = _require3.EV_READY,\n    EV_ADD = _require3.EV_ADD,\n    EV_CHANGE = _require3.EV_CHANGE,\n    EV_UNLINK = _require3.EV_UNLINK,\n    EV_ADD_DIR = _require3.EV_ADD_DIR,\n    EV_UNLINK_DIR = _require3.EV_UNLINK_DIR,\n    EV_RAW = _require3.EV_RAW,\n    EV_ERROR = _require3.EV_ERROR,\n    STR_CLOSE = _require3.STR_CLOSE,\n    STR_END = _require3.STR_END,\n    BACK_SLASH_RE = _require3.BACK_SLASH_RE,\n    DOUBLE_SLASH_RE = _require3.DOUBLE_SLASH_RE,\n    SLASH_OR_BACK_SLASH_RE = _require3.SLASH_OR_BACK_SLASH_RE,\n    DOT_RE = _require3.DOT_RE,\n    REPLACER_RE = _require3.REPLACER_RE,\n    SLASH = _require3.SLASH,\n    SLASH_SLASH = _require3.SLASH_SLASH,\n    BRACE_START = _require3.BRACE_START,\n    BANG = _require3.BANG,\n    ONE_DOT = _require3.ONE_DOT,\n    TWO_DOTS = _require3.TWO_DOTS,\n    GLOBSTAR = _require3.GLOBSTAR,\n    SLASH_GLOBSTAR = _require3.SLASH_GLOBSTAR,\n    ANYMATCH_OPTS = _require3.ANYMATCH_OPTS,\n    STRING_TYPE = _require3.STRING_TYPE,\n    FUNCTION_TYPE = _require3.FUNCTION_TYPE,\n    EMPTY_STR = _require3.EMPTY_STR,\n    EMPTY_FN = _require3.EMPTY_FN,\n    isWindows = _require3.isWindows,\n    isMacos = _require3.isMacos,\n    isIBMi = _require3.isIBMi;\n\nvar stat = promisify(fs.stat);\nvar readdir = promisify(fs.readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nvar arrify = function arrify() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.isArray(value) ? value : [value];\n};\n\nvar flatten = function flatten(list) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  list.forEach(function (item) {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nvar unifyPaths = function unifyPaths(paths_) {\n  /**\n   * @type {Array<String>}\n   */\n  var paths = flatten(arrify(paths_));\n\n  if (!paths.every(function (p) {\n    return typeof p === STRING_TYPE;\n  })) {\n    throw new TypeError(\"Non-string provided as watch path: \".concat(paths));\n  }\n\n  return paths.map(normalizePathToUnix);\n}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\n\nvar toUnix = function toUnix(string) {\n  var str = string.replace(BACK_SLASH_RE, SLASH);\n  var prepend = false;\n\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  if (prepend) {\n    str = SLASH + str;\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nvar normalizePathToUnix = function normalizePathToUnix(path) {\n  return toUnix(sysPath.normalize(toUnix(path)));\n};\n\nvar normalizeIgnored = function normalizeIgnored() {\n  var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;\n  return function (path) {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n};\n\nvar getAbsolutePath = function getAbsolutePath(path, cwd) {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n\n  return sysPath.join(cwd, path);\n};\n\nvar undef = function undef(opts, key) {\n  return opts[key] === undefined;\n};\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nvar DirEntry = /*#__PURE__*/function () {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  function DirEntry(dir, removeWatcher) {\n    _classCallCheck(this, DirEntry);\n\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  _createClass(DirEntry, [{\n    key: \"add\",\n    value: function add(item) {\n      var items = this.items;\n      if (!items) return;\n      if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n    }\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(item) {\n        var items, dir;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                items = this.items;\n\n                if (items) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                items.delete(item);\n\n                if (!(items.size > 0)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 6:\n                dir = this.path;\n                _context.prev = 7;\n                _context.next = 10;\n                return readdir(dir);\n\n              case 10:\n                _context.next = 15;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](7);\n\n                if (this._removeWatcher) {\n                  this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n                }\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 12]]);\n      }));\n\n      function remove(_x) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n  }, {\n    key: \"has\",\n    value: function has(item) {\n      var items = this.items;\n      if (!items) return;\n      return items.has(item);\n    }\n    /**\n     * @returns {Array<String>}\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var items = this.items;\n      if (!items) return;\n      return _toConsumableArray(items.values());\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.items.clear();\n      delete this.path;\n      delete this._removeWatcher;\n      delete this.items;\n      Object.freeze(this);\n    }\n  }]);\n\n  return DirEntry;\n}();\n\nvar STAT_METHOD_F = 'stat';\nvar STAT_METHOD_L = 'lstat';\n\nvar WatchHelper = /*#__PURE__*/function () {\n  function WatchHelper(path, watchPath, follow, fsw) {\n    _classCallCheck(this, WatchHelper);\n\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(function (parts) {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  _createClass(WatchHelper, [{\n    key: \"checkGlobSymlink\",\n    value: function checkGlobSymlink(entry) {\n      // only need to resolve once\n      // first entry should always have entry.parentDir === EMPTY_STR\n      if (this.globSymlink === undefined) {\n        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n          realPath: entry.fullParentDir,\n          linkPath: this.fullWatchPath\n        };\n      }\n\n      if (this.globSymlink) {\n        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n      }\n\n      return entry.fullPath;\n    }\n  }, {\n    key: \"entryPath\",\n    value: function entryPath(entry) {\n      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n    }\n  }, {\n    key: \"filterPath\",\n    value: function filterPath(entry) {\n      var stats = entry.stats;\n      if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n      var resolvedPath = this.entryPath(entry);\n      var matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n    }\n  }, {\n    key: \"getDirParts\",\n    value: function getDirParts(path) {\n      var _this = this;\n\n      if (!this.hasGlob) return [];\n      var parts = [];\n      var expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n      expandedPath.forEach(function (path) {\n        parts.push(sysPath.relative(_this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n      });\n      return parts;\n    }\n  }, {\n    key: \"filterDir\",\n    value: function filterDir(entry) {\n      if (this.hasGlob) {\n        var entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n        var globstar = false;\n        this.unmatchedGlob = !this.dirParts.some(function (parts) {\n          return parts.every(function (part, i) {\n            if (part === GLOBSTAR) globstar = true;\n            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n          });\n        });\n      }\n\n      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n    }\n  }]);\n\n  return WatchHelper;\n}();\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nvar FSWatcher = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(FSWatcher, _EventEmitter);\n\n  // Not indenting methods for history sake; for now.\n  function FSWatcher(_opts) {\n    var _this2;\n\n    _classCallCheck(this, FSWatcher);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(FSWatcher).call(this));\n    var opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    _this2._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    _this2._closers = new Map();\n    /** @type {Set<String>} */\n\n    _this2._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    _this2._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    _this2._symlinkPaths = new Map();\n    _this2._streams = new Set();\n    _this2.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    var canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n\n\n    if (isIBMi) {\n      opts.usePolling = true;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    var envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n    if (envPoll !== undefined) {\n      var envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    var envInterval = process.env.CHOKIDAR_INTERVAL;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) _this2._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    var awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      _this2._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    var readyCalls = 0;\n\n    _this2._emitReady = function () {\n      readyCalls++;\n\n      if (readyCalls >= _this2._readyCount) {\n        _this2._emitReady = EMPTY_FN;\n        _this2._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(function () {\n          return _this2.emit(EV_READY);\n        });\n      }\n    };\n\n    _this2._emitRaw = function () {\n      var _this3;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_this3 = _this2).emit.apply(_this3, [EV_RAW].concat(args));\n    };\n\n    _this2._readyEmitted = false;\n    _this2.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      _this2._fsEventsHandler = new FsEventsHandler(_assertThisInitialized(_assertThisInitialized(_this2)));\n    } else {\n      _this2._nodeFsHandler = new NodeFsHandler(_assertThisInitialized(_assertThisInitialized(_this2)));\n    } // You’re frozen when your heart’s not open.\n\n\n    Object.freeze(opts);\n    return _this2;\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  _createClass(FSWatcher, [{\n    key: \"add\",\n    value: function add(paths_, _origAdd, _internal) {\n      var _this4 = this;\n\n      var _this$options = this.options,\n          cwd = _this$options.cwd,\n          disableGlobbing = _this$options.disableGlobbing;\n      this.closed = false;\n      var paths = unifyPaths(paths_);\n\n      if (cwd) {\n        paths = paths.map(function (path) {\n          var absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n          if (disableGlobbing || !isGlob(path)) {\n            return absPath;\n          }\n\n          return normalizePath(absPath);\n        });\n      } // set aside negated glob strings\n\n\n      paths = paths.filter(function (path) {\n        if (path.startsWith(BANG)) {\n          _this4._ignoredPaths.add(path.slice(1));\n\n          return false;\n        } // if a path is being added that was previously ignored, stop ignoring it\n\n\n        _this4._ignoredPaths.delete(path);\n\n        _this4._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n\n\n        _this4._userIgnored = undefined;\n        return true;\n      });\n\n      if (this.options.useFsEvents && this._fsEventsHandler) {\n        if (!this._readyCount) this._readyCount = paths.length;\n        if (this.options.persistent) this._readyCount *= 2;\n        paths.forEach(function (path) {\n          return _this4._fsEventsHandler._addToFsEvents(path);\n        });\n      } else {\n        if (!this._readyCount) this._readyCount = 0;\n        this._readyCount += paths.length;\n        Promise.all(paths.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path) {\n            var res;\n            return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return _this4._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n\n                  case 2:\n                    res = _context2.sent;\n                    if (res) _this4._emitReady();\n                    return _context2.abrupt(\"return\", res);\n\n                  case 5:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function (_x2) {\n            return _ref.apply(this, arguments);\n          };\n        }())).then(function (results) {\n          if (_this4.closed) return;\n          results.filter(function (item) {\n            return item;\n          }).forEach(function (item) {\n            _this4.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n          });\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Close watchers or start ignoring events from specified paths.\n     * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n     * @returns {FSWatcher} for chaining\n    */\n\n  }, {\n    key: \"unwatch\",\n    value: function unwatch(paths_) {\n      var _this5 = this;\n\n      if (this.closed) return this;\n      var paths = unifyPaths(paths_);\n      var cwd = this.options.cwd;\n      paths.forEach(function (path) {\n        // convert to absolute path unless relative path already matches\n        if (!sysPath.isAbsolute(path) && !_this5._closers.has(path)) {\n          if (cwd) path = sysPath.join(cwd, path);\n          path = sysPath.resolve(path);\n        }\n\n        _this5._closePath(path);\n\n        _this5._ignoredPaths.add(path);\n\n        if (_this5._watched.has(path)) {\n          _this5._ignoredPaths.add(path + SLASH_GLOBSTAR);\n        } // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n\n\n        _this5._userIgnored = undefined;\n      });\n      return this;\n    }\n    /**\n     * Close watchers and remove all listeners from watched paths.\n     * @returns {Promise<void>}.\n    */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this6 = this;\n\n      if (this.closed) return this._closePromise;\n      this.closed = true; // Memory management.\n\n      this.removeAllListeners();\n      var closers = [];\n\n      this._closers.forEach(function (closerList) {\n        return closerList.forEach(function (closer) {\n          var promise = closer();\n          if (promise instanceof Promise) closers.push(promise);\n        });\n      });\n\n      this._streams.forEach(function (stream) {\n        return stream.destroy();\n      });\n\n      this._userIgnored = undefined;\n      this._readyCount = 0;\n      this._readyEmitted = false;\n\n      this._watched.forEach(function (dirent) {\n        return dirent.dispose();\n      });\n\n      ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(function (key) {\n        _this6[\"_\".concat(key)].clear();\n      });\n      this._closePromise = closers.length ? Promise.all(closers).then(function () {\n        return undefined;\n      }) : Promise.resolve();\n      return this._closePromise;\n    }\n    /**\n     * Expose list of watched paths\n     * @returns {Object} for chaining\n    */\n\n  }, {\n    key: \"getWatched\",\n    value: function getWatched() {\n      var _this7 = this;\n\n      var watchList = {};\n\n      this._watched.forEach(function (entry, dir) {\n        var key = _this7.options.cwd ? sysPath.relative(_this7.options.cwd, dir) : dir;\n        watchList[key || ONE_DOT] = entry.getChildren().sort();\n      });\n\n      return watchList;\n    }\n  }, {\n    key: \"emitWithAll\",\n    value: function emitWithAll(event, args) {\n      this.emit.apply(this, _toConsumableArray(args));\n      if (event !== EV_ERROR) this.emit.apply(this, [EV_ALL].concat(_toConsumableArray(args)));\n    } // Common helpers\n    // --------------\n\n    /**\n     * Normalize and emit events.\n     * Calling _emit DOES NOT MEAN emit() would be called!\n     * @param {EventName} event Type of event\n     * @param {Path} path File or directory path\n     * @param {*=} val1 arguments to be passed with event\n     * @param {*=} val2\n     * @param {*=} val3\n     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event, path, val1, val2, val3) {\n        var _this8 = this;\n\n        var opts, args, awf, pw, awfEmit, isThrottled, fullPath, stats;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.closed) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                opts = this.options;\n                if (isWindows) path = sysPath.normalize(path);\n                if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n                /** @type Array<any> */\n\n                args = [event, path];\n                if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n                awf = opts.awaitWriteFinish;\n\n                if (!(awf && (pw = this._pendingWrites.get(path)))) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                pw.lastChange = new Date();\n                return _context3.abrupt(\"return\", this);\n\n              case 11:\n                if (!opts.atomic) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                if (!(event === EV_UNLINK)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                this._pendingUnlinks.set(path, args);\n\n                setTimeout(function () {\n                  _this8._pendingUnlinks.forEach(function (entry, path) {\n                    _this8.emit.apply(_this8, _toConsumableArray(entry));\n\n                    _this8.emit.apply(_this8, [EV_ALL].concat(_toConsumableArray(entry)));\n\n                    _this8._pendingUnlinks.delete(path);\n                  });\n                }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n                return _context3.abrupt(\"return\", this);\n\n              case 16:\n                if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n                  event = args[0] = EV_CHANGE;\n\n                  this._pendingUnlinks.delete(path);\n                }\n\n              case 17:\n                if (!(awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                awfEmit = function awfEmit(err, stats) {\n                  if (err) {\n                    event = args[0] = EV_ERROR;\n                    args[1] = err;\n\n                    _this8.emitWithAll(event, args);\n                  } else if (stats) {\n                    // if stats doesn't exist the file must have been deleted\n                    if (args.length > 2) {\n                      args[2] = stats;\n                    } else {\n                      args.push(stats);\n                    }\n\n                    _this8.emitWithAll(event, args);\n                  }\n                };\n\n                this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n                return _context3.abrupt(\"return\", this);\n\n              case 21:\n                if (!(event === EV_CHANGE)) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                isThrottled = !this._throttle(EV_CHANGE, path, 50);\n\n                if (!isThrottled) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this);\n\n              case 25:\n                if (!(opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE))) {\n                  _context3.next = 38;\n                  break;\n                }\n\n                fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n                _context3.prev = 27;\n                _context3.next = 30;\n                return stat(fullPath);\n\n              case 30:\n                stats = _context3.sent;\n                _context3.next = 35;\n                break;\n\n              case 33:\n                _context3.prev = 33;\n                _context3.t0 = _context3[\"catch\"](27);\n\n              case 35:\n                if (!(!stats || this.closed)) {\n                  _context3.next = 37;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 37:\n                args.push(stats);\n\n              case 38:\n                this.emitWithAll(event, args);\n                return _context3.abrupt(\"return\", this);\n\n              case 40:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[27, 33]]);\n      }));\n\n      function _emit(_x3, _x4, _x5, _x6, _x7) {\n        return _emit2.apply(this, arguments);\n      }\n\n      return _emit;\n    }()\n    /**\n     * Common handler for errors\n     * @param {Error} error\n     * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(error) {\n      var code = error && error.code;\n\n      if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n        this.emit(EV_ERROR, error);\n      }\n\n      return error || this.closed;\n    }\n    /**\n     * Helper utility for throttling\n     * @param {ThrottleType} actionType type being throttled\n     * @param {Path} path being acted upon\n     * @param {Number} timeout duration of time to suppress duplicate actions\n     * @returns {Object|false} tracking object or false if action should be suppressed\n     */\n\n  }, {\n    key: \"_throttle\",\n    value: function _throttle(actionType, path, timeout) {\n      if (!this._throttled.has(actionType)) {\n        this._throttled.set(actionType, new Map());\n      }\n      /** @type {Map<Path, Object>} */\n\n\n      var action = this._throttled.get(actionType);\n      /** @type {Object} */\n\n\n      var actionPath = action.get(path);\n\n      if (actionPath) {\n        actionPath.count++;\n        return false;\n      }\n\n      var timeoutObject;\n\n      var clear = function clear() {\n        var item = action.get(path);\n        var count = item ? item.count : 0;\n        action.delete(path);\n        clearTimeout(timeoutObject);\n        if (item) clearTimeout(item.timeoutObject);\n        return count;\n      };\n\n      timeoutObject = setTimeout(clear, timeout);\n      var thr = {\n        timeoutObject: timeoutObject,\n        clear: clear,\n        count: 0\n      };\n      action.set(path, thr);\n      return thr;\n    }\n  }, {\n    key: \"_incrReadyCount\",\n    value: function _incrReadyCount() {\n      return this._readyCount++;\n    }\n    /**\n     * Awaits write operation to finish.\n     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n     * @param {Path} path being acted upon\n     * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n     * @param {EventName} event\n     * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n     */\n\n  }, {\n    key: \"_awaitWriteFinish\",\n    value: function _awaitWriteFinish(path, threshold, event, awfEmit) {\n      var _this9 = this;\n\n      var timeoutHandler;\n      var fullPath = path;\n\n      if (this.options.cwd && !sysPath.isAbsolute(path)) {\n        fullPath = sysPath.join(this.options.cwd, path);\n      }\n\n      var now = new Date();\n\n      var awaitWriteFinish = function awaitWriteFinish(prevStat) {\n        fs.stat(fullPath, function (err, curStat) {\n          if (err || !_this9._pendingWrites.has(path)) {\n            if (err && err.code !== 'ENOENT') awfEmit(err);\n            return;\n          }\n\n          var now = Number(new Date());\n\n          if (prevStat && curStat.size !== prevStat.size) {\n            _this9._pendingWrites.get(path).lastChange = now;\n          }\n\n          var pw = _this9._pendingWrites.get(path);\n\n          var df = now - pw.lastChange;\n\n          if (df >= threshold) {\n            _this9._pendingWrites.delete(path);\n\n            awfEmit(undefined, curStat);\n          } else {\n            timeoutHandler = setTimeout(awaitWriteFinish, _this9.options.awaitWriteFinish.pollInterval, curStat);\n          }\n        });\n      };\n\n      if (!this._pendingWrites.has(path)) {\n        this._pendingWrites.set(path, {\n          lastChange: now,\n          cancelWait: function cancelWait() {\n            _this9._pendingWrites.delete(path);\n\n            clearTimeout(timeoutHandler);\n            return event;\n          }\n        });\n\n        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n      }\n    }\n  }, {\n    key: \"_getGlobIgnored\",\n    value: function _getGlobIgnored() {\n      return _toConsumableArray(this._ignoredPaths.values());\n    }\n    /**\n     * Determines whether user has asked to ignore this path.\n     * @param {Path} path filepath or dir\n     * @param {fs.Stats=} stats result of fs.stat\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isIgnored\",\n    value: function _isIgnored(path, stats) {\n      if (this.options.atomic && DOT_RE.test(path)) return true;\n\n      if (!this._userIgnored) {\n        var cwd = this.options.cwd;\n        var ign = this.options.ignored;\n        var ignored = ign && ign.map(normalizeIgnored(cwd));\n        var paths = arrify(ignored).filter(function (path) {\n          return typeof path === STRING_TYPE && !isGlob(path);\n        }).map(function (path) {\n          return path + SLASH_GLOBSTAR;\n        });\n\n        var list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n      }\n\n      return this._userIgnored([path, stats]);\n    }\n  }, {\n    key: \"_isntIgnored\",\n    value: function _isntIgnored(path, stat) {\n      return !this._isIgnored(path, stat);\n    }\n    /**\n     * Provides a set of common helpers and properties relating to symlink and glob handling.\n     * @param {Path} path file, directory, or glob pattern being watched\n     * @param {Number=} depth at any depth > 0, this isn't a glob\n     * @returns {WatchHelper} object containing helpers for this path\n     */\n\n  }, {\n    key: \"_getWatchHelpers\",\n    value: function _getWatchHelpers(path, depth) {\n      var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n      var follow = this.options.followSymlinks;\n      return new WatchHelper(path, watchPath, follow, this);\n    } // Directory helpers\n    // -----------------\n\n    /**\n     * Provides directory tracking objects\n     * @param {String} directory path of the directory\n     * @returns {DirEntry} the directory's tracking object\n     */\n\n  }, {\n    key: \"_getWatchedDir\",\n    value: function _getWatchedDir(directory) {\n      if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n      var dir = sysPath.resolve(directory);\n      if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n      return this._watched.get(dir);\n    } // File helpers\n    // ------------\n\n    /**\n     * Check for read permissions.\n     * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n     * @param {fs.Stats} stats - object, result of fs_stat\n     * @returns {Boolean} indicates whether the file can be read\n    */\n\n  }, {\n    key: \"_hasReadPermissions\",\n    value: function _hasReadPermissions(stats) {\n      if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n      var md = stats && Number.parseInt(stats.mode, 10);\n      var st = md & 511;\n      var it = Number.parseInt(st.toString(8)[0], 10);\n      return Boolean(4 & it);\n    }\n    /**\n     * Handles emitting unlink events for\n     * files and directories, and via recursion, for\n     * files and directories within directories that are unlinked\n     * @param {String} directory within which the following item is located\n     * @param {String} item      base path of item/directory\n     * @returns {void}\n    */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(directory, item, isDirectory) {\n      var _this10 = this;\n\n      // if what is being deleted is a directory, get that directory's paths\n      // for recursive deleting and cleaning of watched object\n      // if it is not a directory, nestedDirectoryChildren will be empty array\n      var path = sysPath.join(directory, item);\n      var fullPath = sysPath.resolve(path);\n      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n      // via multiple paths (such as _handleFile and _handleDir)\n\n      if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n        this.add(directory, item, true);\n      } // This will create a new entry in the watched object in either case\n      // so we got to do the directory check beforehand\n\n\n      var wp = this._getWatchedDir(path);\n\n      var nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n      nestedDirectoryChildren.forEach(function (nested) {\n        return _this10._remove(path, nested);\n      }); // Check if item was on the watched list and remove it\n\n      var parent = this._getWatchedDir(directory);\n\n      var wasTracked = parent.has(item);\n      parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n      // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n      // but never removed from the map in case the path was deleted.\n      // This leads to an incorrect state if the path was recreated:\n      // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n\n      if (this._symlinkPaths.has(fullPath)) {\n        this._symlinkPaths.delete(fullPath);\n      } // If we wait for this file to be fully written, cancel the wait.\n\n\n      var relPath = path;\n      if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n        var event = this._pendingWrites.get(relPath).cancelWait();\n\n        if (event === EV_ADD) return;\n      } // The Entry will either be a directory that just got removed\n      // or a bogus entry to a file, in either case we have to remove it\n\n\n      this._watched.delete(path);\n\n      this._watched.delete(fullPath);\n\n      var eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n      if (!this.options.useFsEvents) {\n        this._closePath(path);\n      }\n    }\n    /**\n     * Closes all watchers for a path\n     * @param {Path} path\n     */\n\n  }, {\n    key: \"_closePath\",\n    value: function _closePath(path) {\n      this._closeFile(path);\n\n      var dir = sysPath.dirname(path);\n\n      this._getWatchedDir(dir).remove(sysPath.basename(path));\n    }\n    /**\n     * Closes only file-specific watchers\n     * @param {Path} path\n     */\n\n  }, {\n    key: \"_closeFile\",\n    value: function _closeFile(path) {\n      var closers = this._closers.get(path);\n\n      if (!closers) return;\n      closers.forEach(function (closer) {\n        return closer();\n      });\n\n      this._closers.delete(path);\n    }\n    /**\n     *\n     * @param {Path} path\n     * @param {Function} closer\n     */\n\n  }, {\n    key: \"_addPathCloser\",\n    value: function _addPathCloser(path, closer) {\n      if (!closer) return;\n\n      var list = this._closers.get(path);\n\n      if (!list) {\n        list = [];\n\n        this._closers.set(path, list);\n      }\n\n      list.push(closer);\n    }\n  }, {\n    key: \"_readdirp\",\n    value: function _readdirp(root, opts) {\n      var _this11 = this;\n\n      if (this.closed) return;\n\n      var options = _objectSpread({\n        type: EV_ALL,\n        alwaysStat: true,\n        lstat: true\n      }, opts);\n\n      var stream = readdirp(root, options);\n\n      this._streams.add(stream);\n\n      stream.once(STR_CLOSE, function () {\n        stream = undefined;\n      });\n      stream.once(STR_END, function () {\n        if (stream) {\n          _this11._streams.delete(stream);\n\n          stream = undefined;\n        }\n      });\n      return stream;\n    }\n  }]);\n\n  return FSWatcher;\n}(EventEmitter); // Export FSWatcher class\n\n\nexports.FSWatcher = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nvar watch = function watch(paths, options) {\n  var watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;","map":null,"metadata":{},"sourceType":"script"}